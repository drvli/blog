[{"title":"js基本类型再学习","url":"/2019/11/18/js基本类型再学习/","content":"\n## 基础数据类型\n\n### 概念\n\n- 类型分类与存储方式：\n    - 基础类型(6)：number，string，null,undefined,boolean,symbol(符号，es6 新增)\n    - 引用类型(1):object\n    - 在读取数据的时候，基本类型直接被读取，引用类型被读取的是其存储在内存栈中的地址，这个地址指向真正存储的位置。\n \n### 问题与解答\n1. undefind,not defined,null的区别\n```\nvar a ; a //undefind\nvar a = null ; a //null\na //not defined\n```\n2. 字面量，String()，new String()的区别\n```\n/*** 字面量 ***/\nvar a = ''  //返回值为基本类型\n\n/*** String() ***/\nString(1)    //字符串的构造函数,可以用来转换字符串\n\n/*** new Sring() ***/\nvar a = new String(); //得到的a是个对象\n\n```\n3. 基本类型为什么可以调用属性和方法\n\n```\neg:\nvar a = 111;   \n//a.toString() 过程大致如下：\nvar a1 = new String(\"\");\nvar a = a1.substring(0);\na1 = null;\nconsole.log(a);  // '111'\n\n```\n> 由于基本类型没有.length,.toString()这样的属性和方法，需要通过封装对象才能访问，所以，js会自动为基本类型包装一个封装对象。（ps:null与undefined没有封装对象）\n\n## 深浅拷贝\n - 浅拷贝：基本类型的拷贝 \n - 一层拷贝：\n    \n```\n// 常用的几种方法\n var a = Object.assgin({},obj);\n \n var a = {...obj,c:1};\n \n var a = arr.concat(1);\n```\n    \n- 深拷贝：\n\n```\n//1.序列化\nJSON.parse(JSON.stringfy());\n // JSON.parse(a,[reiver]) 类似深层map  \n // 缺点：\n // 函数，undefined，Symbol序列化后会丢失，不能循环引用\n \n//2.递归遍历\nfunction deepClone(source){\n    const targetObj = source.construtor === Array ? [] : {};\n    for(let key in source){\n        if(source.hasOwnProperty(key)){\n            if(source[key] && typeof source[key] === 'object' ){\n            targetObj[key] =  source.construtor === Array ? [] : {};\n            targetObj[key] = deepClone(source[key]);\n            }else{\n                 targetObj[key] = source[key];\n            }\n        }\n    }\n    return targetObj;\n}\n \n // 3.MessageChannel方法\n```\n\n## 类型判断\n\n### typeof\n\n```\nundefined     // undefined  \nnull           // object     判断错误\n'123'          // string     \n123            // number\ntrue           //boolean\nNaN            // number\ntypeof(Symbol(1)) //symbol\nvar  fn = function(){};\nfn            // funciton  \nvar obj = {},[];\nobj           // object     判断不准确\n        \n```\n### instanceof\n \n```\nconst Student = function() {}\nconst stu = new Student()\nstu instanceof Student   //true\n\nlet str = 'hello'\nstr instanceof String // false\n\nlet str1 = new String('hello')\nstr1 instanceof String // true\n\n```\n\n###  几种好的判断类型的方法\n-  typeOf + instanceof\n\n```\n基本类型可以使用typeof，引用类型使用instanceof\n```\n- 一个数的constructor是否等于其起构造函数的方法\n\n```\n//ps:undefined和null没有属性和方法\n[].constructor === Array //true\n({}).constructor === Object //true\n   new Date().constructor === Date //true\n   /\\d/g.constructor === RegExp()  //true\n'1'.constructor === String //true\n1..constructor === Number //true\nSymbol(1).constructor === Symbol //false 不准确  \n```\n\n> undefined和null没有属性和方法，且Symbol(1).constructor = undefined\n\n- Object.prototype.toString.call()\n\n```\nObject.prototype.toString.call(2) // [object Number]\nObject.prototype.toString.call('222') // [object String]\nObject.prototype.toString.call(true) // [object Boolean]\nObject.prototype.toString.call(Symbol('a')) // [object Symbol]\nObject.prototype.toString.call(new Date()) // [object Date]\nObject.prototype.toString.call(new RegExp()) // [object RegExp]\n\n//=====\nObject.prototype.toString.call(new Map()) //\"[object Map]\"\nObject.prototype.toString.call(function* (){})\n//\"[object GeneratorFunction]\"\nObject.prototype.toString.call(Promise.resolve())\n//\"[object Promise]\"\n\n//===\nclass Vaildator{};\nObject.prototype.toString.call(new Vaildator())\n\"[object Object]\"\n\nclass Vaildator{\n    get[Sybmol.toStringTag](){\n        return 'Vaildator'\n    }\n};\nObject.prototype.toString.call(new Vaildator())\n\"[object Vaildator]\"\n\n```\n> undefined和null没有属性和方法;\n\n> 除了上述提到的Object和Array两种情况，其他类型都不支持非自身实例通过this绑定调用该Object子类原型对象上的toString()方法，这说明它们在重写toString()方法时，明确限定了调用该方法的对象类型，非自身对象实例不可调用。所以，一般我们只使用Object.prototype.toString.call/apply()方法。\n\n> toString()能识别map等是因为引擎为它们设置好了toStringTag标签，自建的类是不能识别的\n\n\n## 类型转换\n\n### valueOf和toString\n - valueOf() 返回这个对象逻辑上对应的原始类型的值。比如说，String包装对象的valueOf()，应该返回这个对象所包装的字符串。\n - toString() 返回这个对象的字符串。用一个字符串来描述这个对象的内容。\n \n\n数据类型 | 例子 | data.valueOf()的结果  | data.toString()的结果 \n---|--- |--- |---\nNumber | 1 | 1 | '1'\nString | '1' | '1' |'1'\nBoolean | false | false | 'false'\nSymbol | Symbol('a') | Symbol(a) |'Symbol(a)'\nArray | [1,2] | [1,2] | \"1,2\"\nFunction | function(){} | ƒ (){} | \"function(){}\"\nObject | var obj = {a:1} | {a: 1} |\"[object Object]\"\nDate | new Date() | 1574030506381 |\"Mon Nov 18 2019 06:42:11 GMT+0800 (中国标准时间)\"\n\n### 内部类型转换的四个方法\n> 这4个方法实际上是ECMAScript定义的4个抽象的操作，它们在js内部使用，进行类型转换\n\n> 这里的ToString()和上面的toString()，一个是js引擎内部使用的函数，另一个是定义在对象上的函数。\n\n1. ToPrimitive ( input [ , PreferredType ] )\n```\n将input转化成一个原始类型的值。PreferredType参数要么不传入，要么是Number或String。如果PreferredType参数是Number，ToPrimitive这样执行：\n    1.如果input本身就是原始类型，直接返回input。\n    2.调用input.valueOf()，如果结果是原始类型，则返回这个结果。\n    3.调用input.toString()，如果结果是原始类型，则返回这个结果。\n    4.抛出TypeError异常。\n以下是PreferredType不为Number时的执行顺序。\n 1.如果PreferredType参数是String，则交换上面这个过程的第2和第3步的顺序，其他执行过程相同。\n 2. 如果PreferredType参数没有传入\n    a.如果input是内置的Date类型，PreferredType视为String\n    b. 否则PreferredType 视为 Number – 先调用valueOf 再调用toString\n```\n2. ToBoolean ( argument )\n\n\n```\nUndefined\tReturn false\nNull\tReturn false\nBoolean\tReturn argument\nNumber\t仅当argument为 +0, -0, or NaN时， return false; 否则一律 return true\nString\t仅当argument是空字符串（长度为0）时， return false; 否则一律 return true\nSymbol\tReturn true\nObject\tReturn true\n```\n\n3. ToNumber ( argument )\n\n\n```\nUndefined\tReturn NaN\nNull\tReturn +0\nBoolean\t如果 argument 为 true, return 1. 如果 argument 为 false, return +0\nNumber\t直接返回argument\nString\t将字符串中的内容转化为数字（比如”23”->23），如果转化失败则返回NaN（比如”23a”->NaN）\nSymbol\t抛出 TypeError 异常\nObject\t先primValue = ToPrimitive(argument, Number)，再对primValue 使用 ToNumber(primValue)\n```\n\n4. ToString ( argument )\n\n```\nUndefined\tReturn “undefined”\nNull\tReturn “null”\nBoolean\t如果 argument 为 true, return “true”.如果 argument 为 false, return “false”\nNumber\t用字符串来表示这个数字\nString\t直接返回 argument\nSymbol\t抛出 TypeError 异常\nObject\t先primValue = ToPrimitive(argument, hint String)，再对primValue使用ToString(primValue)\n```\n### 隐式类型数据转换\n#### if时\n> js期望得到boolean的值，使用ToBoolean ( argument )\n \n \n#### 除过加法以外的计算\n> js期望得到number类型的值，按照计算的优先级顺序使用ToNumber ( argument )\n\n\n```\n 3* { valueOf: function () { return {} }, toString: function () { return {} } }\n \n //调用ToNumber ( argument )的过程中，调用了ToPrimitive ( input , Number )，因为在ToPrimitive中valueOf和toString都没有返回原始类型，所以抛出异常\n```\n\n####  加法(有字符串拼接的含义)\n\n> 只要’+’两端的任意一个操作数是字符串，那么这个’+’就表示字符串拼接，否则表示算数加，使用ToNumber()\n\n\n```\n[]+[]   //  \"\"\n// ToPrimitive([])返回空字符串\n\n[] + {}  \"[object Object]\"\n// ToPrimitive({})返回\"[object Object]\"\n\n{} + []  //  0, {}表示执行代码块儿\n```\n\n#### 比较运算符\n> 如果是对象，就通过 toPrimitive 转换对象\n> 如果是字符串，就通过 unicode 字符索引来比较\n\n##### 双等\n- xy都为Null或undefined,return true; 一方为Null或undefined，return false\n- x或y为NaN, return false;\n- x和y为String，Number，Boolean并且类型不一致，都转为Number再进行比较\n- 存在Object，转换为原始值(valueOf())，再比较\n\n\n### 显示类型转换\n> 调用Boolean(value)、Number(value)、String(value)完成的类型转换，叫做显示类型转换\n>  这三个函数用于类型转换的时候，调用的就是js内部的ToBoolean ( argument )、ToNumber ( argument )、ToString ( argument )方法！\n\n\n```\nString({a:24}); // \"[object Object]\"\n//1.js内部函数ToString\n//2.执行ToPrimitive({a:24}, String)\n//3.因为{a:24}不是原始类型，下一步toString() //'[object,Object]' \n//4.return \n\n\nlet obj2 = {\n\tvalueOf() {\n\t\treturn 2\n\t},\n\ttoString(){\n\t\treturn []\n\t}\n}\nString(obj2)  // '2'\n\n```\n#### parseInt()和parseFloat()\n\n> parseInt只会转换字符串。如果传入的不是字符串会先转换成字符串再进行parse, 调用ToString()方法\n\n\n```\nparseInt(1/0, 19) // 18  => 1/0转换成字符串为Infinity 。而有效数字范围是0-9 a-i 所以第一位为I 代表18。n超出19的范围了所以只有18返回\nparseInt(0.0000008) // 8 => 8e+7  6个0转换成字符串会转换成指数\nparseInt(0.000008) // 0 => 0.000008 \n```\n"},{"title":"Hello World","url":"/2019/11/13/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]